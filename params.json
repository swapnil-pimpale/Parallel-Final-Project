{"name":"Concurrent Lock-free Binary Search Tree","tagline":"","body":"### Summary\r\nWe are going to implement two variants of a synchronized binary search tree (BST) data structure on a shared memory system, and compare the performance of both. Specifically, we will implement a fine-grained locking version, and a lock-free version of the BST, compare the performance of both on a variety of traces. The BST itself will support insert, search and delete operations. The performance will be tested under a variety of conditions - different tree sizes, different workloads and different degrees of contention. The lock-free algorithm will use atomic primitives like compare and swap (CAS), test and set, etc.\r\n\r\n### Background\r\nMulti-core, multi-processor architectures have become the norm these days. Hence, concurrent data structures are becoming increasingly important. Concurrent data structures can be accessed by multiple threads simultaneously. Lock-free programming is programming without locks. A lock-free implementation of a concurrent data structure guarantees that some thread can complete an operation in a finite number of steps regardless of the execution of other threads. Lock‑free programming uses atomic operations, such as atomic swap, test-and-set, fetch-and-add, compare-and-swap, load-link/store-conditional, etc., to maintain consistent state. Lock‑free programming can improve system throughput while avoiding issues with traditional locking based algorithms such as - deadlocks, livelocks, etc.\r\n\r\n### The Challenge\r\nThe primary goal of this project is to implement an efficient lock-free BST and an efficient fine-grain-locked BST, and to analyze the performance of both under various workloads. Naturally, this means that both our BST implementations will be modified by several threads in parallel, and so the challenge would be to ensure that both BST implementations have a final state that is consistent with some interleaving of the various operations performed on it by the various threads. Given the dependencies associated between various nodes in a BST, and the insert, search and delete operations we plan to perform on the tree, we anticipate synchronization to be a challenge, especially lock-free synchronization.\r\n\r\n### Resources\r\nWe plan to test our implementation on both the GHC cluster machines and latedays. The configuration of both are as follows:\r\n* ghc27-46.ghc.andrew.cmu.edu - six-core, 3.2 GHz Intel Xeon CPU\r\n* latedays: Two, six-core Xeon e5-2620 v3 processors (2.4 GHz, 15MB L3 cache, hyper-threading, AVX2 instruction support), 16 GB RAM (60 GB/sec of BW)\r\n\r\nWe are starting from scratch on this project.\r\n\r\n### Goals and Deliverables\r\n**What we plan to achieve and deliver**\r\n\r\n1. Documented source code for multi-threaded, fine-grained locking version of BST\r\n2. Documented source code for multi-threaded, lock-free version of BST\r\n3. Test harness code for performance comparison of both the above implementations\r\n\r\n**What we hope to achieve**\r\n\r\nIf we find ourselves ahead of schedule we plan to scale up the project by implementing a lock free version for another (simpler) data structure.\r\n\r\n### Platform Choice\r\nTo test our implementation we need a shared memory system with high-core count so that we can vary the degree of contention by increasing and decreasing the number of threads accessing the BST. We are going to be using atomic primitives like CAS, test-and-set which are supported by almost all the Intel processors and so we can work with any of the GHC or latedays cluster machines.\r\n\r\n### Schedule\r\nWe are already behind schedule by almost 2 weeks as a result of our proposal change. We plan to engage in a 3 or 4 day coding marathon for the next few days to design our basic test harness, so that we can get back on track.\r\n\r\n* 15th April - 18th April: Design test harness, and fine-grained locking version of BST\r\n* 21st April - 24th April: Work on lock-free version of BST\r\n* 25th April - 29th April: Both of us will be studying for exams, both for parallel and other classes\r\n* 30th April - 4th May: Romit will push forward as aggressively as possible continuing to work on our lock-free implementation, while Swapnil studies for another exam.\r\n* 4th May - 11th May: Swapnil will push forward as aggressively as possible to complete the lock-free implementation, get the project ready for final presentation, while Romit assists while studying for another exam.\r\n\r\n### Checkpoint\r\n#### Overview of work completed\r\n\r\nWe first implemented a basic testing framework as well as a single-threaded BST. The testing framework supported the reading of text files to construct a basic BST, and perform inserts, searches and deletes on a BST. We then augmented the testing framework by adding support to generate multiple threads to work on a single BST, before working on adding fine-grained locking to our BST to enable concurrent access. As of right now, we have implemented fine-grained locking for ‘insert’ operations, as well as ‘delete’ operations. We have performed some basic tests to ensure that our ‘insert’ and ‘delete’ operations are working correctly, but more rigorous testing needs to take place before we can ascertain the correctness of our implementations. In particular, the ‘delete’ operation is tricky due to the large number of cases that can arise as a result of deleting a node from a BST, so it must be tested rigorously. The ‘search’ operation uses identical fine-grained locking semantics to the ‘insert’ operation, so implementing it should not be a challenge.\r\n\r\n#### Goals and Deliverables\r\n\r\nAs stated in our proposal, we plan to implement a fine-grained-locking version of a BST as well as a lock-free version of a BST, and compare their runtime performance on a variety of traces. The deliverables include the source code for both versions of the BST, as well as the test harness code.\r\n\r\nGiven that it seems we are close to completing the fine-grained-locking version of the BST, we should be able to successfully complete both versions of the BST and perform the necessary analysis by the given project deadline. It is uncertain as to whether or not we will have time to implement another lock-free data structure, but it remains a possibility.\r\n\r\n#### Parallelism competition demo\r\n\r\nWe plan to present graphs of the runtime performance of both BST versions against a variety of traces, and explain the resulting trends in the graphs. The traces that we will analyze the performance on include write-heavy workloads, read-heavy workloads and mixed-workloads. Given that this project is more analysis-inclined, it is unlikely that we could produce any sort of meaningful visual demo (if you have suggestions, please let us know!).\r\n\r\n#### Issues that may pose a challenge\r\n\r\nTime and uncertainty pose the biggest challenge as of now. Based on our upcoming schedules, it seems that we will not be able to seriously start on the lock-free BST implementation till the 30th of April or 1st of May, which gives us only 10 days or so to finish the project. However, at that point, we will be done with most of our other classes, so we will be 100% committed to the project.\r\n\r\nAnother issue that poses a challenge is the issue of testing. When performing a sequence of operations concurrently on a BST, the resulting BST will differ from one run to another, since the operations on the BST may be performed in a different order from one run to another. This makes it difficult to verify that our BST implementation is correct, particularly on larger BSTs. Thus far, we have relied on manual verification to ensure that our BST is functioning correctly, but this proves an unreasonable scheme for the workload-sizes we plan to perform runtime analysis on. We do not have a solution to this problem as of now.\r\n\r\n#### Updated Schedule\r\n\r\nIt is difficult for us at this stage to exactly specify what work will be performed at what time, especially during the last week or so. So instead we specify the availability of team members during particular periods of time.\r\n\r\n#### \\#define WORK_ON_OTHER_STUFF\t404\r\n\r\n04/21: Add timing code to the existing test-harness. Get preliminary results for fine grained locked BST. Start designing the lockfree version.\r\n\r\n04/22: 404\r\n\r\n04/23: Complete the lockfree design and start lockfree implementation.\r\n\r\n04/24, 04/25, 04/26, 04/27, 04/28, 04/29: 404 / minimal work on parallel\r\n\r\n04/30, 05/01, 05/02, 05/03: Romit goes 100% during this period.\r\n\r\n05/04, 05/05, 05/06, 05/07: Swapnil joins in. Swapnil available for 100% of the time. Romit available for 50% of the time.\r\n\r\n05/08, 05/09,: Romit pulls a 404 for his database exam. Swapnil finishes the remaining stuff.\r\n\r\n05/10: Presentation preparation, etc.\r\n\r\n05/11: Project Competition\r\n\r\n\r\n### Authors and Contributors\r\nSwapnil Pimpale, Romit Kudtarkar","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}